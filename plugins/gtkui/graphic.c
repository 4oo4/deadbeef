/* graphic.c generated by valac, the Vala compiler
 * generated from graphic.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define DEADBEEF_TYPE_GRAPHIC (deadbeef_graphic_get_type ())
#define DEADBEEF_GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEADBEEF_TYPE_GRAPHIC, DeadbeefGraphic))
#define DEADBEEF_GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEADBEEF_TYPE_GRAPHIC, DeadbeefGraphicClass))
#define DEADBEEF_IS_GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEADBEEF_TYPE_GRAPHIC))
#define DEADBEEF_IS_GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEADBEEF_TYPE_GRAPHIC))
#define DEADBEEF_GRAPHIC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEADBEEF_TYPE_GRAPHIC, DeadbeefGraphicClass))

typedef struct _DeadbeefGraphic DeadbeefGraphic;
typedef struct _DeadbeefGraphicClass DeadbeefGraphicClass;
typedef struct _DeadbeefGraphicPrivate DeadbeefGraphicPrivate;

#define DEADBEEF_GRAPHIC_TYPE_POINT (deadbeef_graphic_point_get_type ())
#define DEADBEEF_GRAPHIC_POINT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEADBEEF_GRAPHIC_TYPE_POINT, DeadbeefGraphicPoint))
#define DEADBEEF_GRAPHIC_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEADBEEF_GRAPHIC_TYPE_POINT, DeadbeefGraphicPointClass))
#define DEADBEEF_GRAPHIC_IS_POINT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEADBEEF_GRAPHIC_TYPE_POINT))
#define DEADBEEF_GRAPHIC_IS_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEADBEEF_GRAPHIC_TYPE_POINT))
#define DEADBEEF_GRAPHIC_POINT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEADBEEF_GRAPHIC_TYPE_POINT, DeadbeefGraphicPointClass))

typedef struct _DeadbeefGraphicPoint DeadbeefGraphicPoint;
typedef struct _DeadbeefGraphicPointClass DeadbeefGraphicPointClass;
#define __g_list_free_deadbeef_graphic_point_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_deadbeef_graphic_point_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
#define _gdk_cursor_unref0(var) ((var == NULL) ? NULL : (var = (gdk_cursor_unref (var), NULL)))
typedef struct _DeadbeefGraphicPointPrivate DeadbeefGraphicPointPrivate;
#define _deadbeef_graphic_point_unref0(var) ((var == NULL) ? NULL : (var = (deadbeef_graphic_point_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _DeadbeefGraphicParamSpecPoint DeadbeefGraphicParamSpecPoint;

struct _DeadbeefGraphic {
	GtkDrawingArea parent_instance;
	DeadbeefGraphicPrivate * priv;
};

struct _DeadbeefGraphicClass {
	GtkDrawingAreaClass parent_class;
};

struct _DeadbeefGraphicPrivate {
	GList* points;
	GList* current_point;
	GdkColor back_color;
	GdkColor fore_bright_color;
	GdkColor fore_dark_color;
	PangoContext* pango_ctx;
	PangoFontDescription* font_desc;
	double* values;
	gint values_length1;
	gint values_size;
	gint mouse_y;
	GdkCursor* moving_cursor;
	GdkCursor* pointer_cursor;
};

struct _DeadbeefGraphicPoint {
	GTypeInstance parent_instance;
	volatile int ref_count;
	DeadbeefGraphicPointPrivate * priv;
	double x;
	double y;
};

struct _DeadbeefGraphicPointClass {
	GTypeClass parent_class;
	void (*finalize) (DeadbeefGraphicPoint *self);
};

struct _DeadbeefGraphicParamSpecPoint {
	GParamSpec parent_instance;
};


extern DeadbeefGraphic* deadbeef_graphic_inst;
DeadbeefGraphic* deadbeef_graphic_inst = NULL;
static gpointer deadbeef_graphic_point_parent_class = NULL;
static gpointer deadbeef_graphic_parent_class = NULL;

#define spot_size 3
#define margin_left 20
#define margin_bottom 10
#define bands 18
GType deadbeef_graphic_get_type (void);
static gpointer deadbeef_graphic_point_ref (gpointer instance);
static void deadbeef_graphic_point_unref (gpointer instance);
static GParamSpec* deadbeef_graphic_param_spec_point (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
static void deadbeef_graphic_value_set_point (GValue* value, gpointer v_object);
static gpointer deadbeef_graphic_value_get_point (const GValue* value);
static GType deadbeef_graphic_point_get_type (void);
#define DEADBEEF_GRAPHIC_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), DEADBEEF_TYPE_GRAPHIC, DeadbeefGraphicPrivate))
enum  {
	DEADBEEF_GRAPHIC_DUMMY_PROPERTY
};
static void _g_list_free_deadbeef_graphic_point_unref (GList* self);
static void deadbeef_graphic_recalc_values (DeadbeefGraphic* self);
DeadbeefGraphic* deadbeef_graphic_new (void);
DeadbeefGraphic* deadbeef_graphic_construct (GType object_type);
static void deadbeef_graphic_abs_to_screen (DeadbeefGraphic* self, double x, double y, GdkPoint* result);
static double deadbeef_graphic_cubic (DeadbeefGraphic* self, double y0, double y1, double y2, double y3, double mu);
static inline double deadbeef_graphic_scale (DeadbeefGraphic* self, double val);
static gboolean deadbeef_graphic_real_expose_event (GtkWidget* base, GdkEventExpose* event);
static gboolean deadbeef_graphic_get_point_at (DeadbeefGraphic* self, double x, double y);
static DeadbeefGraphicPoint* deadbeef_graphic_point_new (void);
static DeadbeefGraphicPoint* deadbeef_graphic_point_construct (GType object_type);
static gboolean deadbeef_graphic_real_button_press_event (GtkWidget* base, GdkEventButton* event);
static gboolean deadbeef_graphic_real_button_release_event (GtkWidget* base, GdkEventButton* event);
static gboolean deadbeef_graphic_real_leave_notify_event (GtkWidget* base, GdkEventCrossing* event);
static gboolean deadbeef_graphic_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event);
enum  {
	DEADBEEF_GRAPHIC_POINT_DUMMY_PROPERTY
};
static void deadbeef_graphic_point_finalize (DeadbeefGraphicPoint* obj);
static void deadbeef_graphic_finalize (GObject* obj);

static const char* freqs[] = {"32", "80", "110", "160", "220", "315", "450", "630", "900", "1.3k", "1.8k", "2.5k", "3.6k", "5k", "7k", "10k", "14k", "20k"};

static void g_cclosure_user_marshal_VOID__POINTER_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static void _g_list_free_deadbeef_graphic_point_unref (GList* self) {
	g_list_foreach (self, (GFunc) deadbeef_graphic_point_unref, NULL);
	g_list_free (self);
}


DeadbeefGraphic* deadbeef_graphic_construct (GType object_type) {
	DeadbeefGraphic * self;
	PangoFontDescription* _tmp0_;
	PangoContext* _tmp1_;
	self = g_object_newv (object_type, 0, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) (((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_LEAVE_NOTIFY_MASK) | GDK_POINTER_MOTION_MASK));
	gtk_widget_modify_bg ((GtkWidget*) self, GTK_STATE_NORMAL, &self->priv->back_color);
	self->priv->font_desc = (_tmp0_ = pango_font_description_from_string ("fixed 4"), _pango_font_description_free0 (self->priv->font_desc), _tmp0_);
	self->priv->pango_ctx = (_tmp1_ = pango_context_new (), _g_object_unref0 (self->priv->pango_ctx), _tmp1_);
	pango_context_set_font_description (self->priv->pango_ctx, self->priv->font_desc);
	deadbeef_graphic_recalc_values (self);
	return self;
}


DeadbeefGraphic* deadbeef_graphic_new (void) {
	return deadbeef_graphic_construct (DEADBEEF_TYPE_GRAPHIC);
}


static void deadbeef_graphic_abs_to_screen (DeadbeefGraphic* self, double x, double y, GdkPoint* result) {
	GdkPoint _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	*result = (memset (&_tmp0_, 0, sizeof (GdkPoint)), _tmp0_.x = ((gint) (x * (((GtkWidget*) self)->allocation.width - margin_left))) + margin_left, _tmp0_.y = (gint) (y * (((GtkWidget*) self)->allocation.height - margin_bottom)), _tmp0_);
	return;
}


static double deadbeef_graphic_cubic (DeadbeefGraphic* self, double y0, double y1, double y2, double y3, double mu) {
	double result;
	double a0 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double a3 = 0.0;
	double mu2 = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	mu2 = mu * mu;
	a0 = ((y3 - y2) - y0) + y1;
	a1 = (y0 - y1) - a0;
	a2 = y2 - y0;
	a3 = y1;
	result = ((((a0 * mu) * mu2) + (a1 * mu2)) + (a2 * mu)) + a3;
	return result;
}


static gpointer _deadbeef_graphic_point_ref0 (gpointer self) {
	return self ? deadbeef_graphic_point_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _pango_font_description_copy0 (gpointer self) {
	return self ? pango_font_description_copy (self) : NULL;
}


static gboolean deadbeef_graphic_real_expose_event (GtkWidget* base, GdkEventExpose* event) {
	DeadbeefGraphic * self;
	gboolean result;
	gint width;
	gint height;
	GdkPoint* _tmp1_;
	gint gpoints_size;
	gint gpoints_length1;
	gint _tmp0_;
	GdkPoint* gpoints;
	GdkPoint _tmp2_ = {0};
	gint i;
	GdkPoint _tmp4_ = {0};
	GdkDrawable* d;
	GdkGCValues _tmp6_;
	GdkGCValues _tmp5_ = {0};
	GdkGC* gc;
	double step;
	double vstep;
	PangoLayout* l;
	PangoContext* ctx;
	PangoFontDescription* fd;
	gboolean _tmp10_ = FALSE;
	GdkRectangle _tmp12_;
	GdkRectangle _tmp11_ = {0};
	gint bar_w;
	GdkPoint gp = {0};
	guint pcount;
	double* _tmp15_;
	gint ys_size;
	gint ys_length1;
	double* ys;
	double* _tmp16_;
	gint xs_size;
	gint xs_length1;
	double* xs;
	gint prev_x;
	gint prev_y;
	self = (DeadbeefGraphic*) base;
	width = ((GtkWidget*) self)->allocation.width;
	height = ((GtkWidget*) self)->allocation.height;
	gpoints = (_tmp1_ = g_new0 (GdkPoint, _tmp0_ = g_list_length (self->priv->points) + 2), gpoints_length1 = _tmp0_, gpoints_size = gpoints_length1, _tmp1_);
	gpoints[0] = (_tmp2_.x = margin_left, _tmp2_.y = (height - margin_bottom) / 2, _tmp2_);
	i = 1;
	{
		GList* p_collection;
		GList* p_it;
		p_collection = self->priv->points;
		for (p_it = p_collection; p_it != NULL; p_it = p_it->next) {
			DeadbeefGraphicPoint* p;
			p = _deadbeef_graphic_point_ref0 ((DeadbeefGraphicPoint*) p_it->data);
			{
				GdkPoint _tmp3_ = {0};
				gpoints[i] = (deadbeef_graphic_abs_to_screen (self, p->x, p->y, &_tmp3_), _tmp3_);
				if (gpoints[i].x >= width) {
					gpoints[i].x = width - 1;
				}
				i++;
				_deadbeef_graphic_point_unref0 (p);
			}
		}
	}
	gpoints[i] = (_tmp4_.x = width - 1, _tmp4_.y = (height - margin_bottom) / 2, _tmp4_);
	d = _g_object_ref0 ((GdkDrawable*) gtk_widget_get_window ((GtkWidget*) self));
	gc = _g_object_ref0 (GDK_DRAWABLE_GET_CLASS (d)->create_gc (d, (_tmp6_ = (memset (&_tmp5_, 0, sizeof (GdkGCValues)), _tmp5_), &_tmp6_), 0));
	gdk_gc_set_rgb_fg_color (gc, &self->priv->fore_dark_color);
	step = ((double) (width - margin_left)) / ((double) (bands - 1));
	{
		gboolean _tmp7_;
		i = 0;
		_tmp7_ = TRUE;
		while (TRUE) {
			if (!_tmp7_) {
				i++;
			}
			_tmp7_ = FALSE;
			if (!(i < bands)) {
				break;
			}
			gdk_draw_line (d, gc, ((gint) (i * step)) + margin_left, 0, ((gint) (i * step)) + margin_left, height - margin_bottom);
		}
	}
	vstep = ((double) (height - margin_bottom)) / 4;
	{
		gboolean _tmp8_;
		i = 1;
		_tmp8_ = TRUE;
		while (TRUE) {
			if (!_tmp8_) {
				i++;
			}
			_tmp8_ = FALSE;
			if (!(i < 4)) {
				break;
			}
			gdk_draw_line (d, gc, margin_left, (gint) (i * vstep), width, (gint) (i * vstep));
		}
	}
	gdk_gc_set_rgb_fg_color (gc, &self->priv->fore_bright_color);
	l = gtk_widget_create_pango_layout ((GtkWidget*) self, NULL);
	ctx = _g_object_ref0 (pango_layout_get_context (l));
	fd = _pango_font_description_copy0 (pango_context_get_font_description (ctx));
	pango_font_description_set_size (fd, 4);
	pango_font_description_set_family_static (fd, "fixed");
	pango_context_set_font_description (ctx, fd);
	{
		gboolean _tmp9_;
		i = 0;
		_tmp9_ = TRUE;
		while (TRUE) {
			if (!_tmp9_) {
				i++;
			}
			_tmp9_ = FALSE;
			if (!(i < bands)) {
				break;
			}
			pango_layout_set_text (l, freqs[i], (gint) g_utf8_strlen (freqs[i], -1));
			gdk_draw_layout (d, gc, ((gint) ((i * step) - 5)) + margin_left, (height - margin_bottom) + 2, l);
		}
	}
	pango_layout_set_width (l, margin_left - 1);
	pango_layout_set_alignment (l, PANGO_ALIGN_RIGHT);
	if (self->priv->mouse_y != (-1)) {
		_tmp10_ = self->priv->mouse_y < (height - margin_bottom);
	} else {
		_tmp10_ = FALSE;
	}
	if (_tmp10_) {
		double db;
		char* tmp;
		db = deadbeef_graphic_scale (self, ((double) (self->priv->mouse_y - 1)) / ((double) ((height - margin_bottom) - 2)));
		tmp = g_strdup_printf ("%.1f", db);
		pango_layout_set_text (l, tmp, (gint) g_utf8_strlen (tmp, -1));
		gdk_draw_layout (d, gc, margin_left - 1, self->priv->mouse_y - 3, l);
		_g_free0 (tmp);
	}
	pango_layout_set_text (l, "-20db", 5);
	gdk_draw_layout (d, gc, margin_left - 1, (height - margin_bottom) - 4, l);
	pango_layout_set_text (l, "20db", 4);
	gdk_draw_layout (d, gc, margin_left - 1, 1, l);
	pango_layout_set_text (l, "0db", 4);
	gdk_draw_layout (d, gc, margin_left - 1, ((height - margin_bottom) / 2) - 3, l);
	gdk_draw_rectangle (d, gc, FALSE, margin_left, 0, (width - margin_left) - 1, (height - margin_bottom) - 1);
	gdk_gc_set_line_attributes (gc, 2, GDK_LINE_SOLID, GDK_CAP_NOT_LAST, GDK_JOIN_MITER);
	gdk_gc_set_clip_rectangle (gc, (_tmp12_ = (_tmp11_.x = margin_left + 1, _tmp11_.y = 1, _tmp11_.width = (width - margin_left) - 2, _tmp11_.height = (height - margin_bottom) - 2, _tmp11_), &_tmp12_));
	gdk_gc_set_rgb_fg_color (gc, &self->priv->fore_dark_color);
	bar_w = 11;
	if (step < bar_w) {
		bar_w = ((gint) step) - 1;
	}
	{
		gboolean _tmp13_;
		i = 0;
		_tmp13_ = TRUE;
		while (TRUE) {
			gint count;
			if (!_tmp13_) {
				i++;
			}
			_tmp13_ = FALSE;
			if (!(i < bands)) {
				break;
			}
			count = ((gint) (((height - margin_bottom) * (1 - self->priv->values[i])) / 6)) + 1;
			{
				gint j;
				j = 0;
				{
					gboolean _tmp14_;
					_tmp14_ = TRUE;
					while (TRUE) {
						if (!_tmp14_) {
							j++;
						}
						_tmp14_ = FALSE;
						if (!(j < count)) {
							break;
						}
						gdk_draw_rectangle (d, gc, TRUE, (((gint) (i * step)) + margin_left) - (bar_w / 2), ((height - margin_bottom) - (j * 6)) - 6, bar_w, 4);
					}
				}
			}
		}
	}
	gdk_gc_set_rgb_fg_color (gc, &self->priv->fore_bright_color);
	pcount = g_list_length (self->priv->points);
	ys = (_tmp15_ = g_new0 (double, pcount), ys_length1 = pcount, ys_size = ys_length1, _tmp15_);
	xs = (_tmp16_ = g_new0 (double, pcount), xs_length1 = pcount, xs_size = xs_length1, _tmp16_);
	i = 0;
	{
		GList* p_collection;
		GList* p_it;
		p_collection = self->priv->points;
		for (p_it = p_collection; p_it != NULL; p_it = p_it->next) {
			DeadbeefGraphicPoint* p;
			p = _deadbeef_graphic_point_ref0 ((DeadbeefGraphicPoint*) p_it->data);
			{
				GdkPoint _tmp17_ = {0};
				gp = (deadbeef_graphic_abs_to_screen (self, p->x, p->y, &_tmp17_), _tmp17_);
				gdk_draw_rectangle (d, gc, TRUE, gp.x - spot_size, gp.y - spot_size, spot_size * 2, spot_size * 2);
				xs[i] = p->x;
				ys[i] = p->y;
				i++;
				_deadbeef_graphic_point_unref0 (p);
			}
		}
	}
	prev_x = 0;
	prev_y = 0;
	if (pcount >= 2) {
		{
			gboolean _tmp18_;
			i = 0;
			_tmp18_ = TRUE;
			while (TRUE) {
				gint pts;
				if (!_tmp18_) {
					i++;
				}
				_tmp18_ = FALSE;
				if (!(i < (pcount - 1))) {
					break;
				}
				fprintf (stdout, "%d\n", (gint) ((xs[i + 1] - xs[i]) * width));
				if (((gint) ((xs[i + 1] - xs[i]) * width)) <= 5) {
					GdkPoint _tmp19_ = {0};
					GdkPoint gp2;
					GdkPoint _tmp20_ = {0};
					gp2 = (deadbeef_graphic_abs_to_screen (self, xs[i], ys[i], &_tmp19_), _tmp19_);
					gp = (deadbeef_graphic_abs_to_screen (self, xs[i + 1], ys[i + 1], &_tmp20_), _tmp20_);
					gdk_draw_line (d, gc, gp2.x, gp2.y, gp.x, gp.y);
					prev_x = gp2.x;
					prev_y = gp2.y;
					continue;
				}
				pts = (gint) (((double) ((xs[i + 1] - xs[i]) * ((GtkWidget*) self)->allocation.width)) / 5.0);
				step = ((double) (xs[i + 1] - xs[i])) / ((double) pts);
				{
					gint ii;
					ii = 0;
					{
						gboolean _tmp21_;
						_tmp21_ = TRUE;
						while (TRUE) {
							double y = 0.0;
							gboolean _tmp22_ = FALSE;
							GdkPoint _tmp23_ = {0};
							if (!_tmp21_) {
								ii++;
							}
							_tmp21_ = FALSE;
							if (!(ii <= pts)) {
								break;
							}
							if (i == 0) {
								_tmp22_ = i == (pcount - 2);
							} else {
								_tmp22_ = FALSE;
							}
							if (_tmp22_) {
								y = deadbeef_graphic_cubic (self, ys[0], ys[0], ys[1], ys[1], ((double) ii) / ((double) pts));
							} else {
								if (i == 0) {
									y = deadbeef_graphic_cubic (self, ys[0], ys[0], ys[1], ys[2], ((double) ii) / ((double) pts));
								} else {
									if (i == (pcount - 2)) {
										y = deadbeef_graphic_cubic (self, ys[i - 1], ys[i], ys[i + 1], ys[i + 1], ((double) ii) / ((double) pts));
									} else {
										y = deadbeef_graphic_cubic (self, ys[i - 1], ys[i], ys[i + 1], ys[i + 2], ((double) ii) / ((double) pts));
									}
								}
							}
							if (y < 0) {
								y = (double) 0;
							}
							if (y > 1) {
								y = (double) 1;
							}
							gp = (deadbeef_graphic_abs_to_screen (self, (ii * step) + xs[i], y, &_tmp23_), _tmp23_);
							if (gp.y < 2) {
								gp.y = 2;
							}
							if (gp.y > ((height - margin_bottom) - 2)) {
								gp.y = (height - margin_bottom) - 2;
							}
							if (prev_x != 0) {
								gdk_draw_line (d, gc, prev_x, prev_y, gp.x, gp.y);
							}
							prev_x = gp.x;
							prev_y = gp.y;
						}
					}
				}
			}
		}
	}
	if (pcount > 0) {
		GdkPoint _tmp24_ = {0};
		GdkPoint _tmp25_ = {0};
		gp = (deadbeef_graphic_abs_to_screen (self, xs[0], ys[0], &_tmp24_), _tmp24_);
		gdk_draw_line (d, gc, margin_left, gp.y, gp.x, gp.y);
		gp = (deadbeef_graphic_abs_to_screen (self, xs[pcount - 1], ys[pcount - 1], &_tmp25_), _tmp25_);
		gdk_draw_line (d, gc, gp.x, gp.y, width - 1, gp.y);
	}
	if (pcount == 0) {
		gdk_draw_line (d, gc, margin_left, (height - margin_bottom) / 2, width - 1, (height - margin_bottom) / 2);
	}
	gdk_gc_set_line_attributes (gc, 1, GDK_LINE_ON_OFF_DASH, GDK_CAP_NOT_LAST, GDK_JOIN_MITER);
	gdk_draw_line (d, gc, 0, self->priv->mouse_y, width, self->priv->mouse_y);
	result = FALSE;
	gpoints = (g_free (gpoints), NULL);
	_g_object_unref0 (d);
	_g_object_unref0 (gc);
	_g_object_unref0 (l);
	_g_object_unref0 (ctx);
	_pango_font_description_free0 (fd);
	ys = (g_free (ys), NULL);
	xs = (g_free (xs), NULL);
	return result;
}


static gboolean deadbeef_graphic_get_point_at (DeadbeefGraphic* self, double x, double y) {
	gboolean result;
	gboolean ret;
	GList* iter;
	double ss_x;
	double ss_y;
	g_return_val_if_fail (self != NULL, FALSE);
	ret = FALSE;
	iter = NULL;
	ss_x = ((double) spot_size) / ((double) ((GtkWidget*) self)->allocation.width);
	ss_y = ((double) spot_size) / ((double) ((GtkWidget*) self)->allocation.height);
	{
		gboolean _tmp0_;
		iter = self->priv->points;
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			if (!_tmp0_) {
				iter = iter->next;
			}
			_tmp0_ = FALSE;
			if (!(iter != NULL)) {
				break;
			}
			if (fabs (((DeadbeefGraphicPoint*) iter->data)->x - x) <= ss_x) {
				_tmp1_ = fabs (((DeadbeefGraphicPoint*) iter->data)->y - y) <= ss_y;
			} else {
				_tmp1_ = FALSE;
			}
			if (_tmp1_) {
				self->priv->current_point = iter;
				ret = TRUE;
				break;
			}
		}
	}
	result = ret;
	return result;
}


static inline double deadbeef_graphic_scale (DeadbeefGraphic* self, double val) {
	double result;
	double k;
	double d;
	g_return_val_if_fail (self != NULL, 0.0);
	k = (double) (-40);
	d = (double) 20;
	result = (val * k) + d;
	return result;
}


static void deadbeef_graphic_recalc_values (DeadbeefGraphic* self) {
	guint pcount;
	double* _tmp0_;
	gint ys_size;
	gint ys_length1;
	double* ys;
	double* _tmp1_;
	gint xs_size;
	gint xs_length1;
	double* xs;
	gint i;
	double* _tmp7_;
	gint scaled_values_size;
	gint scaled_values_length1;
	double* scaled_values;
	g_return_if_fail (self != NULL);
	pcount = g_list_length (self->priv->points);
	ys = (_tmp0_ = g_new0 (double, pcount), ys_length1 = pcount, ys_size = ys_length1, _tmp0_);
	xs = (_tmp1_ = g_new0 (double, pcount), xs_length1 = pcount, xs_size = xs_length1, _tmp1_);
	i = 0;
	{
		GList* p_collection;
		GList* p_it;
		p_collection = self->priv->points;
		for (p_it = p_collection; p_it != NULL; p_it = p_it->next) {
			DeadbeefGraphicPoint* p;
			p = _deadbeef_graphic_point_ref0 ((DeadbeefGraphicPoint*) p_it->data);
			{
				xs[i] = p->x;
				ys[i] = p->y;
				i++;
				_deadbeef_graphic_point_unref0 (p);
			}
		}
	}
	if (pcount == 0) {
		{
			gboolean _tmp2_;
			i = 0;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < bands)) {
					break;
				}
				self->priv->values[i] = 0.5;
			}
		}
	} else {
		if (pcount == 1) {
			{
				gboolean _tmp3_;
				i = 0;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < bands)) {
						break;
					}
					self->priv->values[i] = ys[0];
				}
			}
		} else {
			gint pi;
			pi = 0;
			{
				gboolean _tmp4_;
				i = 0;
				_tmp4_ = TRUE;
				while (TRUE) {
					double x;
					double y;
					gboolean _tmp5_ = FALSE;
					gboolean _tmp6_ = FALSE;
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < bands)) {
						break;
					}
					x = ((double) i) / ((double) (bands - 1));
					y = (double) 0;
					if (xs[pi] > x) {
						self->priv->values[i] = ys[pi];
						continue;
					}
					if (xs[pi + 1] < x) {
						_tmp5_ = pi < (pcount - 1);
					} else {
						_tmp5_ = FALSE;
					}
					if (_tmp5_) {
						pi++;
					}
					if (pi == (pcount - 1)) {
						self->priv->values[i] = ys[pcount - 1];
						continue;
					}
					if (pi == 0) {
						_tmp6_ = pi == (pcount - 2);
					} else {
						_tmp6_ = FALSE;
					}
					if (_tmp6_) {
						y = deadbeef_graphic_cubic (self, ys[pi], ys[pi], ys[pi + 1], ys[pi + 1], (x - xs[pi]) / (xs[pi + 1] - xs[pi]));
					} else {
						if (pi == 0) {
							y = deadbeef_graphic_cubic (self, ys[pi], ys[pi], ys[pi + 1], ys[pi + 2], (x - xs[pi]) / (xs[pi + 1] - xs[pi]));
						} else {
							if (pi == (pcount - 2)) {
								y = deadbeef_graphic_cubic (self, ys[pi - 1], ys[pi], ys[pi + 1], ys[pi + 1], (x - xs[pi]) / (xs[pi + 1] - xs[pi]));
							} else {
								y = deadbeef_graphic_cubic (self, ys[pi - 1], ys[pi], ys[pi + 1], ys[pi + 2], (x - xs[pi]) / (xs[pi + 1] - xs[pi]));
							}
						}
					}
					if (y < 0) {
						y = (double) 0;
					}
					if (y > 1) {
						y = (double) 1;
					}
					self->priv->values[i] = y;
				}
			}
		}
	}
	scaled_values = (_tmp7_ = g_new0 (double, bands), scaled_values_length1 = bands, scaled_values_size = scaled_values_length1, _tmp7_);
	{
		gboolean _tmp8_;
		i = 0;
		_tmp8_ = TRUE;
		while (TRUE) {
			if (!_tmp8_) {
				i++;
			}
			_tmp8_ = FALSE;
			if (!(i < bands)) {
				break;
			}
			scaled_values[i] = deadbeef_graphic_scale (self, self->priv->values[i]);
		}
	}
	g_signal_emit_by_name (self, "on-changed", scaled_values, scaled_values_length1);
	ys = (g_free (ys), NULL);
	xs = (g_free (xs), NULL);
	scaled_values = (g_free (scaled_values), NULL);
}


static gboolean deadbeef_graphic_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	DeadbeefGraphic * self;
	gboolean result;
	double x;
	double y;
	self = (DeadbeefGraphic*) base;
	x = ((double) ((*event).x - margin_left)) / ((double) (((GtkWidget*) self)->allocation.width - margin_left));
	y = (*event).y / ((double) (((GtkWidget*) self)->allocation.height - margin_bottom));
	if ((*event).button == 1) {
		if (!deadbeef_graphic_get_point_at (self, x, y)) {
			DeadbeefGraphicPoint* point;
			point = deadbeef_graphic_point_new ();
			if (self->priv->points == NULL) {
				GList* _tmp0_;
				self->priv->points = (_tmp0_ = NULL, __g_list_free_deadbeef_graphic_point_unref0 (self->priv->points), _tmp0_);
				self->priv->points = g_list_append (self->priv->points, _deadbeef_graphic_point_ref0 (point));
				self->priv->current_point = self->priv->points;
			} else {
				if (((DeadbeefGraphicPoint*) self->priv->points->data)->x > x) {
					self->priv->points = g_list_prepend (self->priv->points, _deadbeef_graphic_point_ref0 (point));
					self->priv->current_point = self->priv->points;
				} else {
					gboolean found;
					found = FALSE;
					{
						GList* i;
						i = self->priv->points;
						{
							gboolean _tmp1_;
							_tmp1_ = TRUE;
							while (TRUE) {
								gboolean _tmp2_ = FALSE;
								if (!_tmp1_) {
									i = i->next;
								}
								_tmp1_ = FALSE;
								if (!(i->next != NULL)) {
									break;
								}
								if (((DeadbeefGraphicPoint*) i->data)->x < x) {
									_tmp2_ = ((DeadbeefGraphicPoint*) i->next->data)->x > x;
								} else {
									_tmp2_ = FALSE;
								}
								if (_tmp2_) {
									self->priv->points = g_list_insert_before (self->priv->points, i->next, _deadbeef_graphic_point_ref0 (point));
									self->priv->current_point = i->next;
									found = TRUE;
									break;
								}
							}
						}
					}
					if (!found) {
						self->priv->points = g_list_append (self->priv->points, _deadbeef_graphic_point_ref0 (point));
						self->priv->current_point = g_list_last (self->priv->points);
					}
				}
			}
			_deadbeef_graphic_point_unref0 (point);
		}
		((DeadbeefGraphicPoint*) self->priv->current_point->data)->x = x;
		((DeadbeefGraphicPoint*) self->priv->current_point->data)->y = y;
		deadbeef_graphic_recalc_values (self);
		gdk_window_set_cursor (gtk_widget_get_window ((GtkWidget*) self), self->priv->moving_cursor);
		gtk_widget_queue_draw ((GtkWidget*) self);
	} else {
		if ((*event).button == 3) {
			if (deadbeef_graphic_get_point_at (self, x, y)) {
				self->priv->points = g_list_remove (self->priv->points, (DeadbeefGraphicPoint*) self->priv->current_point->data);
				deadbeef_graphic_recalc_values (self);
				gtk_widget_queue_draw ((GtkWidget*) self);
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean deadbeef_graphic_real_button_release_event (GtkWidget* base, GdkEventButton* event) {
	DeadbeefGraphic * self;
	gboolean result;
	self = (DeadbeefGraphic*) base;
	gdk_window_set_cursor (gtk_widget_get_window ((GtkWidget*) self), self->priv->pointer_cursor);
	result = FALSE;
	return result;
}


static gboolean deadbeef_graphic_real_leave_notify_event (GtkWidget* base, GdkEventCrossing* event) {
	DeadbeefGraphic * self;
	gboolean result;
	self = (DeadbeefGraphic*) base;
	self->priv->mouse_y = -1;
	gtk_widget_queue_draw ((GtkWidget*) self);
	result = FALSE;
	return result;
}


static gboolean deadbeef_graphic_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event) {
	DeadbeefGraphic * self;
	gboolean result;
	double x;
	double y;
	self = (DeadbeefGraphic*) base;
	x = ((double) ((*event).x - margin_left)) / ((double) (((GtkWidget*) self)->allocation.width - margin_left));
	y = (*event).y / ((double) (((GtkWidget*) self)->allocation.height - margin_bottom));
	if (0 != ((*event).state & GDK_BUTTON1_MASK)) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		((DeadbeefGraphicPoint*) self->priv->current_point->data)->x = x;
		if (self->priv->current_point->prev != NULL) {
			_tmp0_ = ((DeadbeefGraphicPoint*) self->priv->current_point->prev->data)->x > ((DeadbeefGraphicPoint*) self->priv->current_point->data)->x;
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			((DeadbeefGraphicPoint*) self->priv->current_point->data)->x = ((DeadbeefGraphicPoint*) self->priv->current_point->prev->data)->x;
		}
		if (self->priv->current_point->next != NULL) {
			_tmp1_ = ((DeadbeefGraphicPoint*) self->priv->current_point->next->data)->x < ((DeadbeefGraphicPoint*) self->priv->current_point->data)->x;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			((DeadbeefGraphicPoint*) self->priv->current_point->data)->x = ((DeadbeefGraphicPoint*) self->priv->current_point->next->data)->x;
		}
		((DeadbeefGraphicPoint*) self->priv->current_point->data)->y = y;
		if (((DeadbeefGraphicPoint*) self->priv->current_point->data)->x > 1) {
			((DeadbeefGraphicPoint*) self->priv->current_point->data)->x = (double) 1;
		}
		if (((DeadbeefGraphicPoint*) self->priv->current_point->data)->x < 0) {
			((DeadbeefGraphicPoint*) self->priv->current_point->data)->x = (double) 0;
		}
		if (((DeadbeefGraphicPoint*) self->priv->current_point->data)->y > 1) {
			((DeadbeefGraphicPoint*) self->priv->current_point->data)->y = (double) 1;
		}
		if (((DeadbeefGraphicPoint*) self->priv->current_point->data)->y < 0) {
			((DeadbeefGraphicPoint*) self->priv->current_point->data)->y = (double) 0;
		}
		deadbeef_graphic_recalc_values (self);
		self->priv->mouse_y = (gint) (*event).y;
		gtk_widget_queue_draw ((GtkWidget*) self);
	} else {
		if (!deadbeef_graphic_get_point_at (self, x, y)) {
			gdk_window_set_cursor (gtk_widget_get_window ((GtkWidget*) self), self->priv->pointer_cursor);
		} else {
			gdk_window_set_cursor (gtk_widget_get_window ((GtkWidget*) self), self->priv->moving_cursor);
		}
		self->priv->mouse_y = (gint) (*event).y;
		gtk_widget_queue_draw ((GtkWidget*) self);
	}
	result = FALSE;
	return result;
}


static DeadbeefGraphicPoint* deadbeef_graphic_point_construct (GType object_type) {
	DeadbeefGraphicPoint* self;
	self = (DeadbeefGraphicPoint*) g_type_create_instance (object_type);
	return self;
}


static DeadbeefGraphicPoint* deadbeef_graphic_point_new (void) {
	return deadbeef_graphic_point_construct (DEADBEEF_GRAPHIC_TYPE_POINT);
}


static void deadbeef_graphic_value_point_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void deadbeef_graphic_value_point_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		deadbeef_graphic_point_unref (value->data[0].v_pointer);
	}
}


static void deadbeef_graphic_value_point_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = deadbeef_graphic_point_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer deadbeef_graphic_value_point_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* deadbeef_graphic_value_point_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		DeadbeefGraphicPoint* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = deadbeef_graphic_point_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* deadbeef_graphic_value_point_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	DeadbeefGraphicPoint** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = deadbeef_graphic_point_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* deadbeef_graphic_param_spec_point (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	DeadbeefGraphicParamSpecPoint* spec;
	g_return_val_if_fail (g_type_is_a (object_type, DEADBEEF_GRAPHIC_TYPE_POINT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer deadbeef_graphic_value_get_point (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, DEADBEEF_GRAPHIC_TYPE_POINT), NULL);
	return value->data[0].v_pointer;
}


static void deadbeef_graphic_value_set_point (GValue* value, gpointer v_object) {
	DeadbeefGraphicPoint* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, DEADBEEF_GRAPHIC_TYPE_POINT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, DEADBEEF_GRAPHIC_TYPE_POINT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		deadbeef_graphic_point_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		deadbeef_graphic_point_unref (old);
	}
}


static void deadbeef_graphic_point_class_init (DeadbeefGraphicPointClass * klass) {
	deadbeef_graphic_point_parent_class = g_type_class_peek_parent (klass);
	DEADBEEF_GRAPHIC_POINT_CLASS (klass)->finalize = deadbeef_graphic_point_finalize;
}


static void deadbeef_graphic_point_instance_init (DeadbeefGraphicPoint * self) {
	self->ref_count = 1;
}


static void deadbeef_graphic_point_finalize (DeadbeefGraphicPoint* obj) {
	DeadbeefGraphicPoint * self;
	self = DEADBEEF_GRAPHIC_POINT (obj);
}


static GType deadbeef_graphic_point_get_type (void) {
	static GType deadbeef_graphic_point_type_id = 0;
	if (deadbeef_graphic_point_type_id == 0) {
		static const GTypeValueTable g_define_type_value_table = { deadbeef_graphic_value_point_init, deadbeef_graphic_value_point_free_value, deadbeef_graphic_value_point_copy_value, deadbeef_graphic_value_point_peek_pointer, "p", deadbeef_graphic_value_point_collect_value, "p", deadbeef_graphic_value_point_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (DeadbeefGraphicPointClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) deadbeef_graphic_point_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DeadbeefGraphicPoint), 0, (GInstanceInitFunc) deadbeef_graphic_point_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		deadbeef_graphic_point_type_id = g_type_register_fundamental (g_type_fundamental_next (), "DeadbeefGraphicPoint", &g_define_type_info, &g_define_type_fundamental_info, 0);
	}
	return deadbeef_graphic_point_type_id;
}


static gpointer deadbeef_graphic_point_ref (gpointer instance) {
	DeadbeefGraphicPoint* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void deadbeef_graphic_point_unref (gpointer instance) {
	DeadbeefGraphicPoint* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		DEADBEEF_GRAPHIC_POINT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void deadbeef_graphic_class_init (DeadbeefGraphicClass * klass) {
	deadbeef_graphic_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DeadbeefGraphicPrivate));
	GTK_WIDGET_CLASS (klass)->expose_event = deadbeef_graphic_real_expose_event;
	GTK_WIDGET_CLASS (klass)->button_press_event = deadbeef_graphic_real_button_press_event;
	GTK_WIDGET_CLASS (klass)->button_release_event = deadbeef_graphic_real_button_release_event;
	GTK_WIDGET_CLASS (klass)->leave_notify_event = deadbeef_graphic_real_leave_notify_event;
	GTK_WIDGET_CLASS (klass)->motion_notify_event = deadbeef_graphic_real_motion_notify_event;
	G_OBJECT_CLASS (klass)->finalize = deadbeef_graphic_finalize;
	g_signal_new ("on_changed", DEADBEEF_TYPE_GRAPHIC, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__POINTER_INT, G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_INT);
}


static void deadbeef_graphic_instance_init (DeadbeefGraphic * self) {
	GdkColor _tmp0_ = {0};
	GdkColor _tmp1_ = {0};
	GdkColor _tmp2_ = {0};
	self->priv = DEADBEEF_GRAPHIC_GET_PRIVATE (self);
	self->priv->points = NULL;
	self->priv->current_point = NULL;
	self->priv->back_color = (memset (&_tmp0_, 0, sizeof (GdkColor)), _tmp0_.red = (guint16) 0, _tmp0_.green = (guint16) 0, _tmp0_.blue = (guint16) 0, _tmp0_);
	self->priv->fore_bright_color = (memset (&_tmp1_, 0, sizeof (GdkColor)), _tmp1_.red = (guint16) 0xffff, _tmp1_.green = (guint16) 0x7e00, _tmp1_.blue = (guint16) 0, _tmp1_);
	self->priv->fore_dark_color = (memset (&_tmp2_, 0, sizeof (GdkColor)), _tmp2_.red = (guint16) 0x7800, _tmp2_.green = (guint16) 0x3b00, _tmp2_.blue = (guint16) 0, _tmp2_);
	self->priv->values = g_new0 (double, bands);
	self->priv->values_length1 = bands;
	self->priv->values_size = self->priv->values_length1;
	self->priv->moving_cursor = gdk_cursor_new (GDK_FLEUR);
	self->priv->pointer_cursor = gdk_cursor_new (GDK_LEFT_PTR);
}


static void deadbeef_graphic_finalize (GObject* obj) {
	DeadbeefGraphic * self;
	self = DEADBEEF_GRAPHIC (obj);
	__g_list_free_deadbeef_graphic_point_unref0 (self->priv->points);
	_g_object_unref0 (self->priv->pango_ctx);
	_pango_font_description_free0 (self->priv->font_desc);
	self->priv->values = (g_free (self->priv->values), NULL);
	_gdk_cursor_unref0 (self->priv->moving_cursor);
	_gdk_cursor_unref0 (self->priv->pointer_cursor);
	G_OBJECT_CLASS (deadbeef_graphic_parent_class)->finalize (obj);
}


GType deadbeef_graphic_get_type (void) {
	static GType deadbeef_graphic_type_id = 0;
	if (deadbeef_graphic_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (DeadbeefGraphicClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) deadbeef_graphic_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DeadbeefGraphic), 0, (GInstanceInitFunc) deadbeef_graphic_instance_init, NULL };
		deadbeef_graphic_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "DeadbeefGraphic", &g_define_type_info, 0);
	}
	return deadbeef_graphic_type_id;
}



static void g_cclosure_user_marshal_VOID__POINTER_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__POINTER_INT) (gpointer data1, gpointer arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__POINTER_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__POINTER_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_pointer (param_values + 1), g_value_get_int (param_values + 2), data2);
}



